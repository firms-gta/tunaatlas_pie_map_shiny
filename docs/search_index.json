[["index.html", "Documentation on the Dockerfile and the YAML for the Shiny App Chapter 1 Introduction", " Documentation on the Dockerfile and the YAML for the Shiny App Bastien Grasset 2025-01-08 Chapter 1 Introduction Welcome to the documentation for the Dockerfile and YAML used in the Shiny App project. This book covers the following: Dockerfile documentation: Details on the Docker configuration and usage. GitHub actions YAML: An explanation of the CI/CD workflow YAML file. Infrastructure deployment documentation: How to create a ticket for deploying Docker images created for Shiny applications on the Blue-Cloud infrastructure. Running GitHub Actions Locally: Steps for executing GitHub Actions locally for testing. (incoming) Use the table of contents on the left to navigate the sections. "],["dockerfile-documentation.html", "Chapter 2 Dockerfile documentation 2.1 Introduction 2.2 Final Steps", " Chapter 2 Dockerfile documentation 2.1 Introduction This document provides a detailed explanation of the Dockerfile used to set up and deploy a Shiny application. The Dockerfile includes steps for configuring the environment, managing dependencies, and running the Shiny app. This Dockerfile can be used either on its own or in conjunction with the .yml file designed for the CI/CD pipeline on GitHub. This Documentation is based on this Dockerfile: https://github.com/firms-gta/tunaatlas_pie_map_shiny/blob/main/Dockerfile, if you want to reproduce something similar, make sure to update the r-ver the label maintaner and the working directory. FROM rocker/r-ver:4.2.3 Base Image: Uses the rocker/r-ver base image with R version 4.2.3 as the foundation for the container. (use the version of R you’ve been deploying the app on) LABEL maintainer=&quot;Julien Barde &lt;julien.barde@ird.fr&gt;&quot; Maintainer Information: Adds metadata about the person maintaining this Dockerfile. RUN apt-get update &amp;&amp; apt-get install -y \\ sudo \\ pandoc \\ pandoc-citeproc \\ libssl-dev \\ libcurl4-gnutls-dev \\ libxml2-dev \\ libudunits2-dev \\ libproj-dev \\ libgeos-dev \\ libgdal-dev \\ libv8-dev \\ libsodium-dev \\ libsecret-1-dev \\ git \\ libnetcdf-dev \\ curl \\ libjq-dev \\ cmake \\ protobuf-compiler \\ libprotobuf-dev \\ librdf0 \\ librdf0-dev \\ redland-utils &amp;&amp; \\ apt-get clean System Dependencies: Installs system libraries required for building and running the Shiny app. Includes dependencies like pandoc for document conversion, libssl-dev for SSL/TLS, and others for geospatial and network operations. If you want lighter app you will have to reduce the system libraries used, this can be done by removing some and testing the app. If you want to do that I recommend doing it in local rather than with the github CI/CD pipeline. RUN install2.r --error --skipinstalled --ncpus -1 httpuv Installs the httpuv R package, which is a core dependency for Shiny apps. WORKDIR /root/tunaatlas_pie_map_shiny Set Working Directory: Specifies the working directory inside the container. COPY download_GTA_data.R ./download_GTA_data.R RUN Rscript download_GTA_data.R Data Preparation: Copies a script into the container to download necessary datasets, from .zip or .csv files on github. Executes the script using Rscript. This step concern the downloading of data from zip on github. As the script is the less likely to change, this step is at the beggining of the Dockerfile, thus, it will be cached when building. RUN R -e &quot;install.packages(&#39;remotes&#39;, repos=&#39;https://cran.r-project.org/&#39;)&quot; RUN R -e &quot;remotes::install_version(&#39;downloader&#39;, version = &#39;0.4&#39;, upgrade = &#39;never&#39;, repos = &#39;https://cran.r-project.org/&#39;)&quot; RUN R -e &quot;remotes::install_version(&#39;readr&#39;, version = &#39;2.1.5&#39;, upgrade = &#39;never&#39;, repos = &#39;https://cran.r-project.org/&#39;)&quot; Downloading packages for downloading big data: Download packages to download data from DOI (around 300 MB). This can be done using other packages, it can also be integrated to a script. This step is also one of the less likely to change, and the less ## Echo the DOI_CSV_HASH for debugging and to to stop cache if DOI.csv has changed (takes in input the hash of the DOI.csv file created in yml) ARG DOI_CSV_HASH RUN echo &quot;DOI_CSV_HASH=${DOI_CSV_HASH}&quot; &gt; /tmp/doi_csv_hash.txt ## Create data repository to copy DOI.csv, a file listing the dataset to download from zenodo RUN mkdir -p data ## Copy the CSV containing the data to download ## Copy the script downloading the data from the CSV COPY DOI.csv ./DOI.csv COPY update_data.R ./update_data.R RUN Rscript update_data.R This download data from zenodo taking in input a .csv file providing every DOI of the dataset to be downloaded. As this operation takes time and bandwidth, it is strongly recommended to use the cache. For this we check the DOI.csv file and if it didn’t change this operation is not reran. To strongly invalidate or validate the cache we choose to save the hash in a local file as just echoing showed some limitations. NB: It is not yet clear if the renv.lock is changing less than the DOI.csv in the developpement of our shiny app, both of this steps are bandwith and time consuming. Once the DOI.csv is set and is supposed not to change it is passed before the renv.lock hashing. ## ARG defines a constructor argument called RENV_PATHS_ROOT. Its value is passed from the YAML file. An initial value is set up in case the YAML does not provide one ARG RENV_PATHS_ROOT=/root/.cache/R/renv ENV RENV_PATHS_ROOT=${RENV_PATHS_ROOT} ## Set environment variables for renv cache ENV RENV_PATHS_CACHE=${RENV_PATHS_ROOT} ## Echo the RENV_PATHS_ROOT for logging RUN echo &quot;RENV_PATHS_ROOT=${RENV_PATHS_ROOT}&quot; RUN echo &quot;RENV_PATHS_CACHE=${RENV_PATHS_CACHE}&quot; ## Define the build argument for the hash of renv.lock to stop cache if renv.lock has changed ARG RENV_LOCK_HASH RUN if [ -z &quot;${RENV_LOCK_HASH}&quot; ]; then \\ export RENV_LOCK_HASH=$(sha256sum renv.lock | cut -d&#39; &#39; -f1); \\ fi &amp;&amp; \\ echo &quot;RENV_LOCK_HASH=${RENV_LOCK_HASH}&quot; &gt; /tmp/renv_lock_hash.txt ## Create the renv cache directory RUN mkdir -p ${RENV_PATHS_ROOT} ## Install renv package that records the packages used in the shiny app RUN R -e &quot;install.packages(&#39;renv&#39;, repos=&#39;https://cran.r-project.org/&#39;)&quot; ## Copy renv configuration and lockfile COPY renv.lock ./ COPY renv/activate.R renv/ COPY renv/settings.json renv/ ## Restore renv packages RUN R -e &quot;renv::activate()&quot; ## Used to setup the environment (with the path cache) RUN R -e &quot;renv::restore()&quot; ## Copy the rest of the application code COPY . . Similarly, if renv.lock as not changed, all the downloading of the packages will not be done again as the cache image already contains them. We then activate the project to use renv and thus to load the corresonding packages. This action can be put at the all beginning of the dockerfile if the packages are the input that are the less likely to change. NB: Any change in the Dockerfile will remove the use of the cache for the next creation. The ARG RENV_LOCK_HASH corresponds in the yml to $(sha256sum renv.lock | cut -d’ ’ -f1). ## Create the default dataset from DOI and GTA data loading to make launching faster (use of qs for loading and data.table for tidying) RUN Rscript ./create_or_load_default_dataset.R Those lines are very specific to this shiny app, they allow the loading of the dataset and the tidying before launching the app and thus reduce the launching time. They now include as well the removing of some not-usefull-anymore dataset to reduce the size of the Dockerimage. ## Expose port 3838 for the Shiny app EXPOSE 3838 ## Create directories for configuration RUN mkdir -p /etc/tunaatlas_pie_map_shiny/ RUN R -e &quot;library(sf); library(tmap); library(dplyr); library(ggplot2); library(leaflet); library(data.table)&quot; Exposure and directories are mandatory for the launching. RUN R -e &quot;library(sf); library(tmap); library(dplyr); library(ggplot2); library(leaflet); library(data.table)&quot; Those lines are to load big packages prior of the launching to avoid time consuming however it is not clear yet if it works well. #Update it does not. Some good practice can help reducing the time of the launching of the application, as reducing the packages used. 2.2 Final Steps At the end of the Dockerfile: - The CMD statement ensures the Shiny app starts when the container runs: CMD [&quot;R&quot;, &quot;-e&quot;, &quot;shiny::runApp(&#39;/root/tunaatlas_pie_map_shiny&#39;, port=3838, host=&#39;0.0.0.0&#39;)&quot;] The port 3838 is exposed to allow access to the app. "],["github-actions-yaml-documentation.html", "Chapter 3 GitHub Actions YAML Documentation 3.1 Introduction 3.2 Set up Docker Buildx 3.3 Verify Docker images 3.4 Inspect Docker cache 3.5 Build Docker image 3.6 Load Docker image 3.7 Conditional push Docker image 3.8 Conclusion", " Chapter 3 GitHub Actions YAML Documentation 3.1 Introduction This document provides a detailed line-by-line explanation of the GitHub Actions workflow for building and deploying a Docker image for a Shiny app. This documentation is based on this .yml https://github.com/firms-gta/tunaatlas_pie_map_shiny/blob/main/.github/workflows/docker-image_on-CWP_database.yml and linked to this Dockerfile https://github.com/firms-gta/tunaatlas_pie_map_shiny/blob/main/Dockerfile for this specific project. Make sure to apply the changes needed to reproduce this pipeline for your own projects. name: Build and Push Docker Image name: Specifies the name of the workflow as it appears in the GitHub Actions UI. on: push: branches: - &#39;main&#39; tags: - &quot;v*&quot; pull_request: branches: - &#39;main&#39; on: Defines the events that trigger the workflow. push: branches: Runs the workflow when code is pushed to the main branch. tags: Triggers the workflow for tags starting with v (e.g., v1.0.0). pull_request: branches: Runs the workflow for pull requests targeting the main branch. jobs: docker: runs-on: ubuntu-latest timeout-minutes: 140 jobs: Specifies the set of tasks to execute in the workflow. docker: The name of the job. runs-on: Uses the ubuntu-latest virtual environment to run the job. timeout-minutes: Limits the job’s runtime to 140 minutes to prevent hanging jobs. steps: - name: Checkout code uses: actions/checkout@v3 steps: Defines the sequence of actions within the job. name: Descriptive name for the step. uses: Utilizes the actions/checkout@v3 action to clone the repository code into the runner. - name: Calculate renv.lock hash id: renv_lock run: echo &quot;renv_lock_hash=$(sha256sum renv.lock | cut -d&#39; &#39; -f1)&quot; &gt;&gt; $GITHUB_ENV name: Calculates a hash for the renv.lock file to check for changes. id: Assigns an identifier (renv_lock) to reference this step later. run: Executes a shell command to calculate the SHA256 hash of renv.lock and saves it as an environment variable ($GITHUB_ENV). - name: Calculate DOI.csv hash id: doi_csv run: echo &quot;doi_csv_hash=$(sha256sum DOI.csv | cut -d&#39; &#39; -f1)&quot; &gt;&gt; $GITHUB_ENV Similar to the renv.lock step but calculates the hash for DOI.csv. - name: Docker meta id: meta uses: docker/metadata-action@v4 with: images: ghcr.io/firms-gta/tunaatlas_pie_map_shiny flavor: latest=true tags: | type=ref,event=branch type=ref,event=pr type=semver,pattern={{version}} labels: | org.opencontainers.image.url=${{ github.repository }} org.opencontainers.image.source=${{ github.repository }} org.opencontainers.image.title=GlobalTunaAtlasExplorer org.opencontainers.image.description=Interactive Shiny application for Tuna Atlas data visualization org.opencontainers.image.vendor=IRD org.opencontainers.image.author=Bastien Grasset &lt;bastien.grasset@ird.fr&gt; name: Creates metadata for the Docker image. id: Assigns the identifier meta. uses: Runs the docker/metadata-action@v4 action to generate Docker image metadata. with: Configuration inputs for the action: images: Specifies the image repository. flavor: Marks the latest build as true. tags: Defines tagging strategies for the image. labels: Adds metadata labels to the Docker image. - name: Login to image repository uses: docker/login-action@v2 with: registry: ghcr.io username: ${{ github.actor }} password: ${{ secrets.GHCR_TOKEN }} name: Logs into the GitHub Container Registry (GHCR). uses: Utilizes the docker/login-action@v2 to authenticate with GHCR. with: Specifies login details: registry: Target registry (ghcr.io). username: Uses the GitHub actor (user triggering the workflow). password: Uses the GHCR_TOKEN secret for authentication. 3.2 Set up Docker Buildx - name: Set up Docker Buildx uses: docker/setup-buildx-action@v2 with: driver-opts: image=moby/buildkit:master,network=host name: Sets up Docker Buildx, a tool for building multi-platform Docker images. (https://www.docker.com/blog/how-to-rapidly-build-multi-architecture-images-with-buildx/) uses: Utilizes the docker/setup-buildx-action@v2 action to configure Buildx. with: driver-opts: Configures Buildx with a custom driver. The image=moby/buildkit:master specifies the Buildkit image, and network=host sets the network mode. (https://docs.docker.com/reference/cli/docker/buildx/create/) 3.3 Verify Docker images - name: Verify Docker images run: docker images name: Verifies the available Docker images on the runner. run: Executes the docker images command to list all locally available Docker images. 3.4 Inspect Docker cache - name: Inspect Docker cache run: docker buildx du name: Inspects the Docker Buildx cache usage. run: Runs the docker buildx du command to display detailed information about the cache, including its size and usage. 3.5 Build Docker image - name: Build Docker image if: ${{ !contains(github.event.head_commit.message, &#39;No building docker image&#39;) }} run: | BRANCH_NAME=$(echo ${{ github.ref_name }} | tr &#39;/&#39; &#39;_&#39; | tr &#39;:&#39; &#39;_&#39;) if [[ &quot;${{ github.event.inputs.action }}&quot; == &quot;build-no-cache-and-push&quot; ]]; then echo &quot;Building without cache...&quot; docker buildx build --no-cache \\ --progress=plain \\ --build-arg RENV_PATHS_ROOT=${{ env.RENV_PATHS_ROOT }} \\ --build-arg RENV_LOCK_HASH=${{ env.renv_lock_hash }} \\ --build-arg DOI_CSV_HASH=${{ env.doi_csv_hash }} \\ --tag ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${BRANCH_NAME} \\ --output type=docker,dest=/tmp/docker-image.tar \\ . else echo &quot;Building with cache...&quot; docker buildx build \\ --progress=plain \\ --cache-from type=registry,ref=$CACHE_IMAGE:${BRANCH_NAME} \\ --cache-to type=registry,ref=$CACHE_IMAGE:${BRANCH_NAME},mode=max \\ --build-arg RENV_PATHS_ROOT=${{ env.RENV_PATHS_ROOT }} \\ --build-arg RENV_LOCK_HASH=${{ env.renv_lock_hash }} \\ --build-arg DOI_CSV_HASH=${{ env.doi_csv_hash }} \\ --tag ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${BRANCH_NAME} \\ --output type=docker,dest=/tmp/docker-image.tar \\ . fi name: Builds the Docker image. if: Ensures the step is skipped if the commit message contains No building docker image. run: BRANCH_NAME: Converts the branch name into a sanitized format suitable for tagging. Conditional Build: build-no-cache-and-push: If the action input specifies this, the build runs without cache using --no-cache. Otherwise, builds with caching enabled using --cache-from and --cache-to options. --build-arg: Passes environment variables like RENV_PATHS_ROOT, RENV_LOCK_HASH, and DOI_CSV_HASH to the build process. 3.6 Load Docker image - name: Load Docker image if: ${{ github.event_name == &#39;workflow_dispatch&#39; &amp;&amp; contains(github.event.inputs.action, &#39;push&#39;) || github.event_name == &#39;push&#39; &amp;&amp; github.ref_type == &#39;tag&#39; }} run: | docker load -i /tmp/docker-image.tar name: Loads the Docker image tar file into the runner’s Docker environment. if: Ensures the step runs only for: workflow_dispatch events with the push action. push events triggered by tags. run: Uses docker load to import the built image. 3.7 Conditional push Docker image - name: Conditional push Docker image if: ${{ github.event_name == &#39;workflow_dispatch&#39; &amp;&amp; contains(github.event.inputs.action, &#39;push&#39;) || github.event_name == &#39;push&#39; &amp;&amp; github.ref_type == &#39;tag&#39; }} run: | TAG_NAME=$(basename ${GITHUB_REF}) BRANCH_NAME=$(echo ${{ github.ref_name }} | sed &#39;s/[^a-zA-Z0-9_.-]/_/g&#39;) docker tag ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${BRANCH_NAME} ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${TAG_NAME} docker push ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${BRANCH_NAME} docker push ghcr.io/firms-gta/tunaatlas_pie_map_shiny:${TAG_NAME} name: Conditionally pushes the Docker image to the registry. if: Ensures the step runs only for: workflow_dispatch events with the push action. push events triggered by tags. run: TAG_NAME: Extracts the tag name from the GitHub reference. BRANCH_NAME: Sanitizes the branch name for safe use as a tag. docker tag: Tags the built image with the branch name and tag name. docker push: Pushes both branch-specific and tag-specific images to the registry. 3.8 Conclusion This YAML file automates the process of setting up Docker Buildx, building and managing Docker images, and pushing them to a registry, enabling a robust CI/CD pipeline for containerized applications. Make sure to have a repository with a Dockerfile creating the image and to save your .yml in a folder .github/workflows in your repository. "],["deploying-docker-images-on-blue-cloud-infrastructure.html", "Chapter 4 Deploying Docker Images on Blue-Cloud Infrastructure 4.1 Introduction 4.2 Example Ticket 4.3 Conclusion", " Chapter 4 Deploying Docker Images on Blue-Cloud Infrastructure 4.1 Introduction This document explains how to create a ticket for deploying Docker images created for Shiny applications on the Blue-Cloud infrastructure. The process involves specifying the necessary details in the ticket so the infrastructure team can handle the deployment efficiently. 4.1.1 Preliminary Steps Before creating the ticket, ensure the following steps are completed: Pull the Docker Image: Verify that the Docker image can be pulled successfully from the container registry: docker pull ghcr.io/username/my_shiny_app:latest Test the Image Locally: Run the Docker image locally to confirm it works as expected: docker run --rm -p 3838:3838 ghcr.io/username/my_shiny_app:latest Access the app at http://localhost:3838 and validate its functionality. 4.1.2 Information to include in the ticket When creating a ticket to deploy a Shiny application as a Docker image, ensure the following details are included: 4.1.2.1 1. Docker image details Image Name: Provide the full name and tag of the Docker image (e.g., ghcr.io/username/my_shiny_app:latest). Container Registry URL: Include the URL where the image is hosted (e.g., GitHub Container Registry). 4.1.2.2 2. Application information App Name: A descriptive name for the Shiny application. Display Name: The name as it should appear in the VRE. Description: A brief summary of the app’s purpose and functionality. 4.1.2.3 3. Run command Provide the exact Docker run command or equivalent details, such as: CMD [&quot;R&quot;, &quot;-e&quot;, &quot;shiny::runApp(&#39;/root/my_shiny_app&#39;, host=&#39;0.0.0.0&#39;, port=3838&#39;)&quot;] 4.1.2.4 5. Resource requirements Mention any specific resource requirements for the application, such as: - Memory limits - CPU requirements. 4.1.2.5 6. Testing and validation Indicate if the image has been tested locally and confirm that it is functional: 4.2 Example Ticket Below is an example of how to structure the ticket: Request for Shiny App Deployment Docker Image: ghcr.io/username/my_shiny_app:latest Container Registry URL: https://ghcr.io/username/my_shiny_app App Name: My Shiny App Display Name: My Shiny App Description: This app provides a visual analysis of XYZ data. Run Command: CMD [“R”, “-e”, “shiny::runApp(‘/root/my_shiny_app’, host=‘0.0.0.0’, port=3838’)”] Application Path: /root/my_shiny_app Resource Requirements: 2 GB RAM, 1 CPU Testing: The app has been tested locally using: 4.3 Conclusion By including all the necessary information in your ticket, you can ensure the infrastructure team has what they need to deploy your Shiny app efficiently and correctly. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
